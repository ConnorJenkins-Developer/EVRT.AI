<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>EVRT ‚Äî Cybersecurity</title>
  <meta name="description" content="Zero-trust by default. Live anomaly detection. Incident automation. Explore EVRT‚Äôs interactive 3D defense model."/>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300..900&family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="assets/style.css"/>

  <style>
    /* Page-scoped polish */
    .chips { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .chip { display:inline-flex; align-items:center; gap:.45rem; padding:.35rem .7rem; border-radius:999px; border:1px solid var(--line); background:#0e121b; }

    /* Sections */
    .section-tight { padding: 18px 0 26px; }

    /* 3D demo layout */
    .defense-grid { display:grid; gap:18px; }
    @media (min-width: 1020px){ .defense-grid { grid-template-columns: 360px 1fr; } }
    .tool { border:1px solid var(--line); background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02)); border-radius:16px; padding:16px; }
    .tool h3 { margin:.25rem 0 .5rem; }
    .muted { color: var(--muted); }

    .btnbar { display:flex; gap:10px; flex-wrap:wrap; }
    .btn.primary { background:linear-gradient(90deg,hsl(var(--accent)),hsl(var(--accent-2))); border-color:transparent; color:#fff; }

    /* Scene card */
    .scene-card { position:relative; border:1px solid var(--line); border-radius:16px; overflow:hidden;
      background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.015)); }
    #scene { display:block; width:100%; height:520px; }
    @media (max-width: 520px){ #scene { height: 420px; } }

    .hud {
      position:absolute; left:12px; bottom:12px; display:flex; gap:8px; flex-wrap:wrap;
      font-size:.85rem; color:#cfd6ff; pointer-events:none;
      text-shadow:0 2px 12px rgba(0,0,0,.55);
    }
    .hud .k { background:rgba(10,14,23,.6); border:1px solid var(--line); padding:.35rem .55rem; border-radius:10px; }
    .legend { position:absolute; right:12px; top:12px; display:flex; gap:8px; flex-wrap:wrap; }
    .legend .key { display:flex; align-items:center; gap:.45rem; border:1px solid var(--line); padding:.25rem .5rem; border-radius:10px; background:rgba(10,14,23,.5); }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
    .dot.blue { background:#6da8ff; box-shadow:0 0 10px #6da8ff; }
    .dot.green{ background:#5cf2c9; box-shadow:0 0 10px #5cf2c9; }
    .dot.red  { background:#ff6b91; box-shadow:0 0 10px #ff6b91; }

    .metrics { display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:10px; margin-top:10px; }
    .metrics .m { border:1px dashed var(--line); padding:10px; border-radius:12px; text-align:center; }
    .metrics .v { font-weight:800; font-size:1.2rem; }

    .toggles { display:grid; gap:8px; margin-top:8px; }
    .toggles label { display:flex; align-items:center; gap:.6rem; }
    .toggles input { accent-color:hsl(var(--accent)); }

    .seg { display:inline-flex; gap:6px; border:1px solid var(--line); background:#0e121b; padding:4px; border-radius:999px; }
    .seg button { border:0; background:transparent; color:var(--text); padding:.45rem .8rem; border-radius:999px; font-weight:700; cursor:pointer; }
    .seg button.active { background:linear-gradient(90deg,hsl(var(--accent)/.35),hsl(var(--accent-2)/.35)); }

    /* Services grid */
    .svc-grid { display:grid; gap:18px; }
    @media (min-width: 900px){ .svc-grid { grid-template-columns: repeat(3,minmax(0,1fr)); } }
    .card { border:1px solid var(--line); border-radius:16px; padding:16px; background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.015)); }
    .icon { width:40px; height:40px; border-radius:12px; display:grid; place-items:center; margin-bottom:10px;
      background:linear-gradient(135deg,hsl(var(--accent)/.25),hsl(var(--accent-2)/.25)); color:#fff; }
  </style>
</head>
<body>
  <div class="bg-orbs" aria-hidden="true"></div>
  <div data-include="partials/header.html"></div>

  <!-- Hero -->
  <section class="container hero">
    <span class="eyebrow">Security</span>
    <h1 class="gradient-text">Cybersecurity, engineered for blast-radius zero</h1>
    <p class="sub">Zero-trust by default. Live anomaly detection. Incident automation. See it work in the 3D defense model below.</p>
    <div class="chips">
      <span class="chip">SOC 2 (in progress)</span>
      <span class="chip">SASE / Zero-Trust</span>
      <span class="chip">WAF / RASP</span>
      <span class="chip">Managed Detection & Response</span>
    </div>
  </section>

  <!-- 3D Defense Model -->
  <section class="container section">
    <div class="defense-grid">
      <aside class="tool">
        <h3>Live defense controls</h3>
        <p class="muted">Toggle protections and launch scenarios. The scene reacts in real-time.</p>

        <div class="toggles" id="toggles">
          <label><input type="checkbox" data-k="waf" checked/> WAF & API Shield</label>
          <label><input type="checkbox" data-k="zt" checked/> Zero-Trust access (IAM/Policies)</label>
          <label><input type="checkbox" data-k="mdr" checked/> Managed Detection & Response</label>
          <label><input type="checkbox" data-k="rate" checked/> Adaptive rate-limit / DDoS</label>
        </div>

        <div style="margin:12px 0 6px"><strong>Launch a scenario</strong></div>
        <div class="btnbar">
          <button class="btn" id="sPhish">Phishing ‚Üí token reuse</button>
          <button class="btn" id="sDdos">DDoS burst</button>
          <button class="btn" id="sLateral">Lateral movement</button>
        </div>

        <div style="margin:12px 0 6px"><strong>Scene</strong></div>
        <div class="btnbar">
          <button class="btn" id="tour">Auto-tour</button>
          <button class="btn" id="reset">Reset</button>
          <button class="btn" id="exportPng">Export PNG</button>
        </div>

        <div class="metrics">
          <div class="m"><div class="v" id="mBlocked">0</div><div class="muted">Blocked</div></div>
          <div class="m"><div class="v" id="mAnom">0</div><div class="muted">Anomalies</div></div>
          <div class="m"><div class="v" id="mAllowed">0</div><div class="muted">Allowed</div></div>
        </div>

        <div style="margin-top:10px">
          <div class="seg" role="tablist" aria-label="Traffic">
            <button class="active" data-traffic="balanced">Balanced</button>
            <button data-traffic="high">High</button>
            <button data-traffic="low">Low</button>
          </div>
        </div>

        <p class="muted" style="margin-top:10px">Tip: drag to orbit ¬∑ scroll to zoom ¬∑ dbl-click to focus core.</p>
      </aside>

      <div class="scene-card">
        <canvas id="scene"></canvas>
        <div class="legend">
          <div class="key"><span class="dot blue"></span> Legit traffic</div>
          <div class="key"><span class="dot red"></span> Attack vector</div>
          <div class="key"><span class="dot green"></span> Sensor alert</div>
        </div>
        <div class="hud">
          <div class="k">WAF</div>
          <div class="k">Zero-Trust</div>
          <div class="k">MDR</div>
        </div>
      </div>
    </div>
  </section>

  <!-- Services -->
  <section class="container section-tight">
    <h2 class="gradient-text" style="font-family:'Space Grotesk',Inter,sans-serif">Security capabilities</h2>
    <div class="svc-grid" style="margin-top:12px">
      <div class="card" data-reveal>
        <div class="icon">üõ°Ô∏è</div>
        <strong>Threat modeling</strong>
        <p class="muted">Map assets, attack paths, and blast radius. Prioritize fixes that measurably reduce risk.</p>
      </div>
      <div class="card" data-reveal>
        <div class="icon">üõ∞Ô∏è</div>
        <strong>MDR & SIEM</strong>
        <p class="muted">Continuous monitoring with anomaly detection, playbooks, and on-call response.</p>
      </div>
      <div class="card" data-reveal>
        <div class="icon">üß©</div>
        <strong>AppSec: WAF / RASP</strong>
        <p class="muted">Runtime protection at the edge and inside your apps. False-positive tuning included.</p>
      </div>
      <div class="card" data-reveal>
        <div class="icon">‚òÅÔ∏è</div>
        <strong>Cloud posture</strong>
        <p class="muted">CSPM for AWS/GCP/Azure: identity, network, storage, and KMS baselines with drift alerts.</p>
      </div>
      <div class="card" data-reveal>
        <div class="icon">üö®</div>
        <strong>Incident response</strong>
        <p class="muted">Retainers with SLAs. Contain, investigate, and recover with forensic reporting.</p>
      </div>
      <div class="card" data-reveal>
        <div class="icon">üîê</div>
        <strong>Zero-Trust rollout</strong>
        <p class="muted">Strong auth, least-privilege policies, device posture, and segmented networks.</p>
      </div>
    </div>
    <div style="margin-top:14px">
      <a href="contact.html" class="btn primary">Get a security assessment</a>
    </div>
  </section>

  <div data-include="partials/footer.html"></div>

  <!-- THREE.JS SCENE -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // --------- DOM helpers
    const $ = s => document.querySelector(s);
    const $$ = s => [...document.querySelectorAll(s)];

    // --------- State
    const features = { waf:true, zt:true, mdr:true, rate:true };
    const metrics = { blocked:0, anomalies:0, allowed:0 };
    let trafficMode = 'balanced';

    // --------- Renderer / scene
    const canvas = $('#scene');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(55, 2, 0.1, 100);
    camera.position.set(10, 6, 12);
    scene.add(camera);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.maxDistance = 26;
    controls.minDistance = 4;

    // Lights
    const amb = new THREE.AmbientLight(0x98a8ff, 0.7);
    scene.add(amb);
    const dir = new THREE.DirectionalLight(0x88aaff, 0.7);
    dir.position.set(5, 8, 5);
    scene.add(dir);

    // Core (Your protected services)
    const coreMat = new THREE.MeshStandardMaterial({
      color: 0x0e1a2a,
      emissive: 0x1a2b55,
      emissiveIntensity: 0.65,
      roughness: 0.5,
      metalness: 0.2
    });
    const core = new THREE.Mesh(new THREE.IcosahedronGeometry(1.6, 2), coreMat);
    scene.add(core);

    // Halo
    const halo = new THREE.Mesh(
      new THREE.SphereGeometry(2.1, 32, 32),
      new THREE.MeshBasicMaterial({ color:0x4ea6ff, transparent:true, opacity:0.08 })
    );
    scene.add(halo);

    // Shields
    const wafRing = new THREE.Mesh(
      new THREE.TorusGeometry(6.2, 0.08, 16, 160),
      new THREE.MeshBasicMaterial({ color:0x6da8ff, transparent:true, opacity:0.65 })
    );
    scene.add(wafRing);

    const ztShell = new THREE.Mesh(
      new THREE.SphereGeometry(4.6, 48, 48),
      new THREE.MeshBasicMaterial({ color:0x5cf2c9, wireframe:true, transparent:true, opacity:0.25 })
    );
    scene.add(ztShell);

    // Network nodes
    const group = new THREE.Group();
    scene.add(group);
    const nodeCount = (innerWidth < 900) ? 24 : 40;
    const nodes = [];
    const nodeGeo = new THREE.SphereGeometry(0.15, 16, 16);
    const nodeMat = new THREE.MeshBasicMaterial({ color:0xa6b4ff });

    function randomOnSphere(r){
      const u = Math.random();
      const v = Math.random();
      const theta = 2*Math.PI*u;
      const phi = Math.acos(2*v - 1);
      const x = r*Math.sin(phi)*Math.cos(theta);
      const y = r*Math.sin(phi)*Math.sin(theta);
      const z = r*Math.cos(phi);
      return new THREE.Vector3(x,y,z);
    }

    for (let i=0;i<nodeCount;i++){
      const p = randomOnSphere(5.8 + Math.random()*0.6);
      const n = new THREE.Mesh(nodeGeo, nodeMat.clone());
      n.position.copy(p);
      n.material.color.setHSL(0.62 + Math.random()*0.05, 0.6, 0.65);
      group.add(n);
      nodes.push(n);
    }

    // Thin connecting arcs (aesthetic)
    const arcMat = new THREE.LineBasicMaterial({ color:0x2b3450, transparent:true, opacity:0.6 });
    for (let i=0;i<nodeCount;i+=2){
      const a = nodes[i].position;
      const b = nodes[(i+7)%nodeCount].position;
      const mid = a.clone().add(b).multiplyScalar(0.5).setLength(6.3);
      const curve = new THREE.CatmullRomCurve3([a, mid, b]);
      const g = new THREE.BufferGeometry().setFromPoints(curve.getPoints(32));
      const l = new THREE.Line(g, arcMat);
      scene.add(l);
    }

    // Traffic particles
    const particles = [];
    const pGeo = new THREE.SphereGeometry(0.07, 8, 8);
    const legitMat = new THREE.MeshBasicMaterial({ color:0x6da8ff });
    const attackMat = new THREE.MeshBasicMaterial({ color:0xff6b91 });

    function spawnParticle(type='legit'){
      const start = randomOnSphere(9.5);
      const target = (type==='legit') ? randomOnSphere(3.2) : new THREE.Vector3(0,0,0);
      const m = (type==='legit') ? legitMat.clone() : attackMat.clone();
      const mesh = new THREE.Mesh(pGeo, m);
      mesh.position.copy(start);
      const speed = (type==='legit') ? (0.02 + Math.random()*0.015) : (0.028 + Math.random()*0.02);
      particles.push({ mesh, start, target, type, speed, alive:true });
      scene.add(mesh);
    }

    // Sensors (MDR beacons)
    const sensorGeo = new THREE.SphereGeometry(0.09, 12, 12);
    for (let i=0;i<10;i++){
      const s = new THREE.Mesh(sensorGeo, new THREE.MeshBasicMaterial({ color:0x5cf2c9 }));
      s.position.copy(randomOnSphere(4.8));
      scene.add(s);
    }

    // Scenarios
    function scenarioPhish(){
      // a few attacks slipping past edge; ZT should catch
      for (let i=0;i<6;i++) spawnParticle('attack');
    }
    function scenarioDdos(){
      for (let i=0;i<28;i++) setTimeout(()=>spawnParticle('attack'), i*45);
    }
    function scenarioLateral(){
      // legit traffic + hidden attack
      for (let i=0;i<8;i++) spawnParticle('legit');
      for (let i=0;i<5;i++) setTimeout(()=>spawnParticle('attack'), i*60);
    }

    // Traffic pump
    let pump = 0;
    function pumpRate(){
      return trafficMode==='high' ? 3 : trafficMode==='low' ? 0.5 : 1;
    }

    // Resize
    function resizeRendererToDisplaySize(){
      const { clientWidth, clientHeight } = canvas;
      const needResize = canvas.width !== clientWidth || canvas.height !== clientHeight;
      if (needResize){
        renderer.setSize(clientWidth, clientHeight, false);
        camera.aspect = clientWidth / clientHeight;
        camera.updateProjectionMatrix();
      }
      return needResize;
    }
    const ro = new ResizeObserver(()=>resizeRendererToDisplaySize());
    ro.observe(canvas);

    // HUD metrics
    function updateMetrics(){
      $('#mBlocked').textContent = metrics.blocked;
      $('#mAnom').textContent = metrics.anomalies;
      $('#mAllowed').textContent = metrics.allowed;
    }

    // Collision helpers (radii)
    const R_WAF = 6.2, R_ZT = 4.6, R_CORE = 1.6;

    // Animation loop
    let t = 0;
    function animate(){
      requestAnimationFrame(animate);
      t += 0.016;

      // gentle movement
      group.rotation.y += 0.0008;
      wafRing.rotation.z += 0.0012;
      ztShell.rotation.y -= 0.0009;

      // spawn ambient legit traffic
      pump += 0.02 * pumpRate();
      if (pump > 1){ pump = 0; spawnParticle('legit'); }

      // step particles
      for (const p of particles){
        if (!p.alive) continue;
        const dir = p.target.clone().sub(p.mesh.position).normalize();
        p.mesh.position.addScaledVector(dir, p.speed);

        const r = p.mesh.position.length();

        // WAF / edge block
        if (features.waf && p.type==='attack' && r < R_WAF - 0.05 && r > R_ZT + 0.05){
          // randomize: block most at edge
          if (Math.random() < 0.8){
            p.alive = false;
            metrics.blocked++;
            updateMetrics();
            // spark
            explode(p.mesh.position, 0xff6b91);
            scene.remove(p.mesh);
            continue;
          }
        }

        // Zero-Trust block near services
        if (features.zt && p.type==='attack' && r < R_ZT - 0.05){
          if (Math.random() < 0.85){
            p.alive = false;
            metrics.blocked++;
            updateMetrics();
            explode(p.mesh.position, 0x5cf2c9);
            scene.remove(p.mesh);
            continue;
          }
        }

        // MDR anomaly ping (visual only)
        if (features.mdr && p.type==='attack' && r < 5.2 && Math.random() < 0.015){
          metrics.anomalies++; updateMetrics();
          ping(p.mesh.position);
        }

        // Reached core
        if (r < R_CORE + 0.05){
          p.alive = false;
          scene.remove(p.mesh);
          if (p.type === 'attack'){
            // Breach if protections off
            core.material.emissiveIntensity = 1.2;
            setTimeout(()=> core.material.emissiveIntensity = 0.65, 220);
          } else {
            metrics.allowed++; updateMetrics();
          }
        }
      }

      // clean up dead
      for (let i=particles.length-1; i>=0; i--){
        if (!particles[i].alive) particles.splice(i,1);
      }

      controls.update();
      resizeRendererToDisplaySize();
      renderer.render(scene, camera);
    }
    animate();

    // Simple FX
    function explode(pos, color=0xffffff){
      const g = new THREE.BufferGeometry();
      const N = 20;
      const positions = new Float32Array(N*3);
      const dirs = [];
      for (let i=0;i<N;i++){
        const v = randomOnSphere(1);
        positions.set([pos.x,pos.y,pos.z], i*3);
        dirs.push(v.multiplyScalar(0.06 + Math.random()*0.06));
      }
      g.setAttribute('position', new THREE.BufferAttribute(positions,3));
      const m = new THREE.PointsMaterial({ size: 0.06, color, transparent:true, opacity:0.95 });
      const pts = new THREE.Points(g,m);
      scene.add(pts);
      let life = 24;
      const id = setInterval(()=>{
        life--;
        const arr = pts.geometry.attributes.position.array;
        for (let i=0;i<N;i++){
          arr[i*3]   += dirs[i].x;
          arr[i*3+1] += dirs[i].y;
          arr[i*3+2] += dirs[i].z;
        }
        pts.geometry.attributes.position.needsUpdate = true;
        pts.material.opacity *= 0.92;
        if (life<=0){ clearInterval(id); scene.remove(pts); pts.geometry.dispose(); }
      }, 16);
    }

    function ping(pos){
      const geo = new THREE.RingGeometry(0.1, 0.12, 32);
      const mat = new THREE.MeshBasicMaterial({ color:0x5cf2c9, transparent:true, opacity:0.9, side:THREE.DoubleSide });
      const ring = new THREE.Mesh(geo, mat);
      ring.position.copy(pos);
      scene.add(ring);
      let s = 1, life = 24;
      const id = setInterval(()=>{
        life--;
        s += 0.12;
        ring.scale.set(s,s,1);
        ring.material.opacity *= 0.9;
        if (life<=0){ clearInterval(id); scene.remove(ring); geo.dispose(); }
      }, 16);
    }

    // --------- UI bindings
    $('#sPhish').addEventListener('click', scenarioPhish);
    $('#sDdos').addEventListener('click', scenarioDdos);
    $('#sLateral').addEventListener('click', scenarioLateral);

    $('#tour').addEventListener('click', ()=>{
      const start = camera.position.clone();
      const target = new THREE.Vector3(0,0,0);
      let t = 0;
      const id = setInterval(()=>{
        t += 0.02;
        camera.position.x = start.x*Math.cos(0.02) + start.z*Math.sin(0.02);
        camera.position.z = start.z*Math.cos(0.02) - start.x*Math.sin(0.02);
        camera.lookAt(target);
        if (t>6){ clearInterval(id); }
      }, 16);
    });

    $('#reset').addEventListener('click', ()=>{
      metrics.blocked = metrics.anomalies = metrics.allowed = 0;
      updateMetrics();
      for (const p of particles){ p.alive=false; scene.remove(p.mesh); }
      particles.length = 0;
      core.material.emissiveIntensity = 0.65;
      camera.position.set(10,6,12);
      controls.update();
    });

    // Export PNG of canvas
    $('#exportPng').addEventListener('click', ()=>{
      const url = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url; a.download = 'evrt-security-scene.png';
      a.click();
    });

    // Feature toggles
    $$('#toggles input[type="checkbox"]').forEach(cb=>{
      cb.addEventListener('change', ()=>{
        features[cb.dataset.k] = cb.checked;
      });
    });

    // Traffic mode
    $$('[data-traffic]').forEach(b=>{
      b.addEventListener('click', ()=>{
        $$('[data-traffic]').forEach(x=>x.classList.remove('active'));
        b.classList.add('active');
        trafficMode = b.dataset.traffic;
      });
    });

    // Accessibility helpers
    canvas.addEventListener('dblclick', ()=>{ controls.target.set(0,0,0); });

    // Initial metrics
    updateMetrics();
  </script>
</body>
</html>
