<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>EVRT ‚Äî Cybersecurity</title>
  <meta name="description" content="Zero-trust architecture, continuous monitoring, incident response, and compliance‚Äîvisualized with a live 3D defense model."/>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300..900&family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="assets/style.css"/>

  <!-- Page-scoped styles -->
  <style>
    .hero { padding-bottom: 12px; }
    .badge-row { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px }
    .badge { display:inline-flex; align-items:center; gap:.45rem; padding:.35rem .6rem; border-radius:999px; border:1px solid var(--line); background:#0e121b; font-size:.9rem }
    .cyber-wrap { padding: 18px 0 28px; }
    .grid-auto { display:grid; gap:18px }
    @media (min-width: 980px) { .grid-auto { grid-template-columns: 1.2fr .8fr } }

    .card.soft { border:1px solid var(--line); border-radius:16px; padding:16px; background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02)); }
    .card-title { margin:.1rem 0 .6rem; font-family:"Space Grotesk",Inter,sans-serif }

    /* 3D canvas holder */
    .defense-stage { position:relative; border:1px solid var(--line); border-radius:16px; overflow:hidden; background:#0a0f17; box-shadow:var(--shadow-lg) }
    .stage-head { display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid var(--line) }
    .stage-body { position:relative; height: min(72vh, 620px); min-height: 380px }
    canvas.webgl { position:absolute; inset:0; width:100%; height:100% }

    .overlay-ui { position:absolute; right:10px; bottom:10px; display:flex; gap:8px; flex-wrap:wrap }
    .chip { display:inline-flex; align-items:center; gap:.45rem; padding:.35rem .6rem; border-radius:999px; border:1px solid var(--line); background:#0e121b; }
    .kbd { padding:.1rem .45rem; border:1px solid var(--line); border-radius:6px; background:#0c111a; font-size:.85rem; color:var(--muted) }

    /* Controls */
    .controls { display:grid; gap:12px }
    .row.two { display:grid; grid-template-columns:1fr 1fr; gap:10px }
    @media (max-width:760px){ .row.two { grid-template-columns:1fr } }
    .fld { display:flex; flex-direction:column; gap:6px }
    .fld input[type="range"] { width:100% }
    .switch { display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px; border:1px solid var(--line); border-radius:12px; background:#0e121b }
    .switch input { transform: scale(1.2) }
    .metric { display:grid; grid-template-columns: repeat(3,minmax(0,1fr)); gap:10px; margin-top:10px }
    .metric .m { border:1px dashed var(--line); border-radius:12px; padding:10px; text-align:center }
    .metric .m .v { font-size:1.2rem; font-weight:800 }
    .btnbar { display:flex; gap:10px; flex-wrap:wrap }
    .btn.primary { background:linear-gradient(90deg,hsl(var(--accent)),hsl(var(--accent-2))); border-color:transparent; color:#fff }

    /* Service tiles */
    .svc-grid { display:grid; gap:16px; grid-template-columns: repeat(3,minmax(0,1fr)) }
    @media (max-width:980px){ .svc-grid { grid-template-columns: 1fr 1fr } }
    @media (max-width:680px){ .svc-grid { grid-template-columns: 1fr } }
    .svc { border:1px solid var(--line); border-radius:16px; padding:16px; background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.015)) }
    .svc .icon { width:40px; height:40px; border-radius:12px; display:grid; place-items:center;
                 background:linear-gradient(135deg,hsl(var(--accent)/.25),hsl(var(--accent-2)/.25)); color:#fff; margin-bottom:10px }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .bg-orbs { animation: none !important; }
    }
  </style>
</head>
<body>
  <div class="bg-orbs" aria-hidden="true"></div>
  <div data-include="partials/header.html"></div>

  <section class="container hero">
    <span class="eyebrow">Security</span>
    <h1 class="gradient-text">Cybersecurity, engineered for blast-radius zero</h1>
    <p class="sub">Zero-trust by default. Live anomaly detection. Incident automation. See it work in the 3D defense model below.</p>
    <div class="badge-row">
      <span class="badge">SOC 2 (in progress)</span>
      <span class="badge">SASE / Zero-Trust</span>
      <span class="badge">WAF / RASP</span>
      <span class="badge">Managed Detection & Response</span>
    </div>
  </section>

  <section class="container cyber-wrap grid-auto">
    <!-- 3D Defense Model -->
    <div class="defense-stage card soft" data-reveal>
      <div class="stage-head">
        <div style="display:flex;align-items:center;gap:10px">
          <span class="logo-mark" aria-hidden="true"></span>
          <strong>EVRT Defense Sphere</strong>
        </div>
        <div class="chip">Drag to orbit ‚Ä¢ <span class="kbd">Shift</span> + drag to pan ‚Ä¢ wheel to zoom</div>
      </div>
      <div class="stage-body">
        <canvas class="webgl" id="gl"></canvas>
        <div class="overlay-ui">
          <span class="chip" id="liveAttacks">Attacks: 0</span>
          <span class="chip" id="deflected">Deflected: 0</span>
          <span class="chip" id="uptime">Uptime: 99.99%</span>
        </div>
      </div>
    </div>

    <!-- Interactive Controls -->
    <aside class="card soft controls" data-reveal>
      <h3 class="card-title">Defense controls</h3>
      <div class="row two">
        <div class="fld">
          <label for="attackRate"><strong>Attack intensity</strong> <span class="muted" id="attackRateVal">Medium</span></label>
          <input type="range" id="attackRate" min="0" max="100" value="45" step="1">
        </div>
        <div class="fld">
          <label for="noise"><strong>Anomaly sensitivity</strong> <span class="muted" id="noiseVal">Balanced</span></label>
          <input type="range" id="noise" min="0" max="100" value="50" step="1">
        </div>
      </div>
      <div class="switch"><span>Zero-Trust Segmentation</span><input type="checkbox" id="segToggle" checked></div>
      <div class="switch"><span>WAF + Runtime Shield</span><input type="checkbox" id="wafToggle" checked></div>
      <div class="switch"><span>Behavioral ML Detection</span><input type="checkbox" id="mlToggle" checked></div>
      <div class="btnbar">
        <button class="btn" id="pulseBtn">Inject burst</button>
        <button class="btn primary" id="autoSimBtn" aria-pressed="false">Start auto-simulation</button>
      </div>
      <div class="metric">
        <div class="m"><div class="v" id="kpiMTTD">‚Äî</div><div class="muted">MTTD</div></div>
        <div class="m"><div class="v" id="kpiMTTR">‚Äî</div><div class="muted">MTTR</div></div>
        <div class="m"><div class="v" id="kpiBlocked">‚Äî</div><div class="muted">Blocked</div></div>
      </div>
    </aside>
  </section>

  <!-- Services -->
  <section class="container section" data-reveal>
    <h2 class="gradient-text" style="font-family:'Space Grotesk',Inter,sans-serif;margin:0 0 10px">What we secure</h2>
    <div class="svc-grid">
      <div class="svc"><div class="icon">üõ°Ô∏è</div><strong>Zero-Trust & SASE</strong><p class="muted">Segment every app & identity. Least-privilege enforced at the edge.</p></div>
      <div class="svc"><div class="icon">üß™</div><strong>Penetration Testing</strong><p class="muted">Red-team exercises, cloud posture reviews, exploit path mapping.</p></div>
      <div class="svc"><div class="icon">üõ∞Ô∏è</div><strong>24/7 MDR</strong><p class="muted">Managed detection & response with continuous telemetry ingestion.</p></div>
      <div class="svc"><div class="icon">üöí</div><strong>Incident Response</strong><p class="muted">Containment runbooks, forensics, and recovery time objectives.</p></div>
      <div class="svc"><div class="icon">üîè</div><strong>AppSec: WAF/RASP</strong><p class="muted">Runtime shielding for OWASP Top 10, API protection, and bot defense.</p></div>
      <div class="svc"><div class="icon">üìú</div><strong>Compliance</strong><p class="muted">SOC 2 (in progress), HIPAA-ready patterns, audit trails & export.</p></div>
    </div>
  </section>

  <!-- CTA -->
  <section class="container section" data-reveal>
    <div class="card soft" style="display:flex;gap:16px;align-items:center;justify-content:space-between;flex-wrap:wrap">
      <div>
        <h3 style="margin:.25rem 0">Ready to reduce blast radius to near-zero?</h3>
        <p class="muted" style="margin:.25rem 0 0">Get a security assessment or plug EVRT controls into your stack.</p>
      </div>
      <div class="btnbar">
        <a class="btn" href="consulting.html">Security assessment</a>
        <a class="btn primary" href="contact.html">Talk to security</a>
      </div>
    </div>
  </section>

  <div data-include="partials/footer.html"></div>

  <!-- Three.js (module) -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.157.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.157.0/examples/jsm/controls/OrbitControls.js';

    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    // Scene setup
    const canvas = document.getElementById('gl');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    const scene = new THREE.Scene();

    const stage = canvas.parentElement;
    const camera = new THREE.PerspectiveCamera(55, stage.clientWidth / stage.clientHeight, 0.1, 200);
    camera.position.set(0, 2.2, 6.5);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 3.8;
    controls.maxDistance = 12;
    controls.enablePan = true;

    // Lighting
    scene.add(new THREE.AmbientLight(0x7aa0ff, 0.7));
    const key = new THREE.DirectionalLight(0x89b4ff, 1.0); key.position.set(5, 6, 4); scene.add(key);
    const rim = new THREE.PointLight(0x8a5bff, 0.7); rim.position.set(-4, -3, -2); scene.add(rim);

    // Core sphere (the "shield")
    const sphereGeo = new THREE.SphereGeometry(2, 64, 64);
    const sphereMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color('hsl(220, 40%, 26%)'),
      metalness: 0.2,
      roughness: 0.35,
      emissive: new THREE.Color('hsl(220, 90%, 55%)'),
      emissiveIntensity: 0.12,
      transparent: true,
      opacity: 0.95
    });
    const shield = new THREE.Mesh(sphereGeo, sphereMat);
    scene.add(shield);

    // Wireframe grid on shield
    const wire = new THREE.LineSegments(
      new THREE.WireframeGeometry(new THREE.SphereGeometry(2.02, 18, 12)),
      new THREE.LineBasicMaterial({ color: new THREE.Color('hsl(210, 80%, 70%)'), transparent:true, opacity:0.25 })
    );
    scene.add(wire);

    // Defensive rings (togglable)
    const ringMat = new THREE.MeshBasicMaterial({ color: new THREE.Color('hsl(200, 90%, 60%)'), wireframe: true, transparent: true, opacity: 0.35 });
    const ring1 = new THREE.Mesh(new THREE.TorusGeometry(2.6, 0.02, 16, 200), ringMat.clone());
    const ring2 = new THREE.Mesh(new THREE.TorusGeometry(3.1, 0.02, 16, 200), ringMat.clone());
    ring1.rotation.x = Math.PI * 0.35; ring2.rotation.y = Math.PI * 0.45;
    scene.add(ring1, ring2);

    // Particle halo
    const pointsGeo = new THREE.BufferGeometry();
    const count = 1500;
    const positions = new Float32Array(count * 3);
    for (let i=0;i<count;i++){
      const r = 3.6 + Math.random() * 0.6;
      const phi = Math.acos(2*Math.random() - 1);
      const theta = Math.random() * Math.PI * 2;
      positions[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
      positions[i*3+1] = r * Math.cos(phi);
      positions[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
    }
    pointsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const pointsMat = new THREE.PointsMaterial({ size: 0.015, color: 0x7fb0ff, transparent: true, opacity: 0.85 });
    const halo = new THREE.Points(pointsGeo, pointsMat);
    scene.add(halo);

    // Threat system
    const threats = [];
    const threatGeo = new THREE.SphereGeometry(0.06, 12, 12);
    const threatMat = new THREE.MeshBasicMaterial({ color: 0xff5a75 });
    const beams = new THREE.Group(); scene.add(beams);

    function spawnThreat(intensity=1){
      for (let i=0;i<intensity;i++){
        const dist = 8 + Math.random()*2;
        const phi = Math.acos(2*Math.random()-1);
        const theta = Math.random()*Math.PI*2;
        const pos = new THREE.Vector3(
          dist * Math.sin(phi) * Math.cos(theta),
          dist * Math.cos(phi),
          dist * Math.sin(phi) * Math.sin(theta)
        );
        const target = new THREE.Vector3().copy(pos).multiplyScalar(0.0); // aim center
        const v = new THREE.Vector3().subVectors(target, pos).normalize().multiplyScalar(0.015 + Math.random()*0.02);
        const m = new THREE.Mesh(threatGeo, threatMat.clone());
        m.position.copy(pos);
        threats.push({ m, v });
        scene.add(m);
        live.attacks++;
      }
    }

    function deflect(threat){
      // beam arc
      const from = threat.m.position.clone();
      const to = from.clone().normalize().multiplyScalar(2.05 + Math.random()*0.2);
      const mid = from.clone().add(to).multiplyScalar(0.5).add(new THREE.Vector3(0, 0.6, 0));
      const curve = new THREE.QuadraticBezierCurve3(from, mid, to);
      const curvePts = curve.getPoints(20);
      const curveGeo = new THREE.BufferGeometry().setFromPoints(curvePts);
      const curveMat = new THREE.LineBasicMaterial({ color: 0x6df0ff, transparent: true, opacity: 0.9 });
      const line = new THREE.Line(curveGeo, curveMat);
      beams.add(line);
      // fade out
      setTimeout(()=> { curveMat.opacity = 0.6; }, 120);
      setTimeout(()=> { curveMat.opacity = 0.2; }, 260);
      setTimeout(()=> { beams.remove(line); line.geometry.dispose(); curveMat.dispose(); }, 520);

      live.deflected++;
      scene.remove(threat.m);
      threat.m.geometry.dispose();
    }

    // Live counters + KPIs
    const live = { attacks: 0, deflected: 0 };
    const elAttacks = document.getElementById('liveAttacks');
    const elDeflected = document.getElementById('deflected');
    const elMTTD = document.getElementById('kpiMTTD');
    const elMTTR = document.getElementById('kpiMTTR');
    const elBlocked = document.getElementById('kpiBlocked');

    function updateHud(){
      elAttacks.textContent = `Attacks: ${live.attacks}`;
      elDeflected.textContent = `Deflected: ${live.deflected}`;
      // toy KPIs based on ratios + sensitivity
      const s = Number(noise.value)/100;
      const blockedRate = live.attacks ? (live.deflected / live.attacks) : 0;
      const mttd = Math.max(0.2, (1 - s)*1.2 + (1 - blockedRate)*0.8); // seconds
      const mttr = Math.max(1.2, 3.2 - blockedRate*2.2); // seconds
      elMTTD.textContent = `${mttd.toFixed(1)}s`;
      elMTTR.textContent = `${mttr.toFixed(1)}s`;
      elBlocked.textContent = `${Math.round(blockedRate*100) || 0}%`;
    }

    // Render loop
    let t = 0;
    function raf(){
      if (!prefersReduced) {
        t += 0.01;
        shield.rotation.y += 0.0025;
        wire.rotation.y -= 0.0018;
        halo.rotation.y += 0.0009;
        ring1.rotation.z += 0.0012;
        ring2.rotation.x -= 0.0010;
      }
      // advance threats
      for (let i=threats.length-1;i>=0;i--){
        const th = threats[i];
        th.m.position.add(th.v);
        if (th.m.position.length() <= 2.06) {
          deflect(th);
          threats.splice(i,1);
        } else if (th.m.position.length() > 12) {
          scene.remove(th.m); threats.splice(i,1);
        }
      }
      controls.update();
      renderer.render(scene, camera);
      updateHud();
      requestAnimationFrame(raf);
    }

    // Resize
    function resize(){
      const w = stage.clientWidth, h = stage.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h; camera.updateProjectionMatrix();
    }
    resize(); window.addEventListener('resize', resize);

    // Controls wiring
    const attackRate = document.getElementById('attackRate');
    const noise = document.getElementById('noise');
    const attackRateVal = document.getElementById('attackRateVal');
    const noiseVal = document.getElementById('noiseVal');
    const segToggle = document.getElementById('segToggle');
    const wafToggle = document.getElementById('wafToggle');
    const mlToggle = document.getElementById('mlToggle');
    const pulseBtn = document.getElementById('pulseBtn');
    const autoSimBtn = document.getElementById('autoSimBtn');

    function label(val, low='Low', mid='Medium', high='High'){
      if (val < 35) return low;
      if (val > 65) return high;
      return mid;
    }
    attackRate.addEventListener('input', ()=> attackRateVal.textContent = label(attackRate.value));
    noise.addEventListener('input', ()=> noiseVal.textContent = label(noise.value, 'Sensitive', 'Balanced', 'Lenient'));
    attackRateVal.textContent = label(attackRate.value);
    noiseVal.textContent = label(noise.value, 'Sensitive', 'Balanced', 'Lenient');

    pulseBtn.addEventListener('click', ()=> spawnThreat(20));

    // toggles affect visuals
    segToggle.addEventListener('change', ()=> { ring1.visible = segToggle.checked; });
    wafToggle.addEventListener('change', ()=> { ring2.visible = wafToggle.checked; });
    mlToggle.addEventListener('change', ()=> { pointsMat.opacity = mlToggle.checked ? 0.85 : 0.25; });

    // autosim
    let autoTimer = null;
    function startAuto(){
      if (autoTimer) return;
      autoSimBtn.textContent = 'Stop auto-simulation';
      autoSimBtn.setAttribute('aria-pressed','true');
      autoTimer = setInterval(()=>{
        const n = 2 + Math.floor((attackRate.value/100) * 14);
        spawnThreat(n);
      }, 260);
    }
    function stopAuto(){
      if (!autoTimer) return;
      clearInterval(autoTimer); autoTimer = null;
      autoSimBtn.textContent = 'Start auto-simulation';
      autoSimBtn.setAttribute('aria-pressed','false');
    }
    autoSimBtn.addEventListener('click', ()=> autoTimer ? stopAuto() : startAuto());

    // subtle ambient spawning
    setInterval(()=> { if (!prefersReduced && !autoTimer) spawnThreat(1); }, 900);

    // Kick
    requestAnimationFrame(raf);

    // Accessibility: pause motion if user changes OS setting mid-session
    try {
      window.matchMedia('(prefers-reduced-motion: reduce)').addEventListener('change', (e)=>{
        if (e.matches) stopAuto();
      });
    } catch {}
  </script>
</body>
</html>
